import { v } from "convex/values";
import { action, internalAction, internalMutation, internalQuery } from "./_generated/server";
import { internal } from "./_generated/api";
import { ChatOpenAI } from "langchain/chat_models/openai";
import { ChatPromptTemplate } from "langchain/prompts";
import { JsonOutputFunctionsParser } from "langchain/output_parsers";
import { createStructuredOutputRunnable } from "langchain/chains/openai_functions";

export const getElement = internalAction({
    args: {
        element1: v.string(),
        element2: v.string()
    },
    handler: async (ctx, {element1, element2}) => {
        element1 = element1.toLowerCase()
        element2 = element2.toLowerCase()
        const element: any  = await ctx.runQuery(internal.alchemy.queryElement, {element1, element2})
        if(element){
            return element
        }

        const response: any = await ctx.runAction(internal.alchemy.generateElement, {element1, element2})

        if(response){
            const insertResponse: any = await ctx.runMutation(internal.alchemy.insertElement, {
                element1: element1.toLowerCase(), element2: element2.toLowerCase(), result: response.result.toLowerCase(), emoji: response.emoji, isNothing: response.isNothing
            })
            response._id = insertResponse
            response.element1 = element1
            response.element2 = element2
            return response
        }
        return {
            _id: null,
            result: "Nothing",
            emoji: "",
            isNothing: true
        }

    }
}
)

export const queryElement = internalQuery({
    args: {
        element1: v.string(),
        element2: v.string()
    },
    handler: async (ctx, {element1, element2}) => {
        return await ctx.db.query("elements")
                    .filter(q => q.eq(q.field("element1"),element1))
                    .filter(q => q.eq(q.field("element2"),element2))
                    .first()
    }
})

export const insertElement = internalMutation({
    args: {
        element1: v.string(),
        element2: v.string(),
        result: v.string(),
        emoji: v.string(),
        isNothing: v.boolean()
    },
    handler: async (ctx, {element1, element2, result, emoji, isNothing}) => {
        return await ctx.db.insert("elements", {
            element1, element2, result, emoji, isNothing
        })
    }
})

export const generateElement = internalAction(
    {
        args: {
            element1: v.string(),
            element2: v.string()
        },
        handler: async (ctx, {element1, element2}) => {
            const schema = {
                title: "Element",
                // description: "Alchemy element generator when provided two elements. If no element can be formed, the returned element is 'Nothing'.",
                description: "Representation of an alchemical element generated by combining two input elements. Alchemy is the mystical science of transmutation, where practitioners blend and transform base elements into new substances of power and wonder. This schema defines the structure for representing the outcome of such transformations. If there can be no emoji attached, produce 'nothing'.",
                type: "object",
                properties: {
                    result: {
                        type: "string",
                        description: "Resulting element"
                    },
                    emoji:{
                        type: "string",
                        description: "Single emoji representation of the resulting element. The length of this string should be 1"
                    },
                    isNothing: {
                        type: "boolean",
                        description: "If no element can be formed"
                    },
                },
                required: ["result","isNothing","emoji"],
              };

              const model = new ChatOpenAI({
                modelName: "gpt-3.5-turbo",
              })

              const prompt = ChatPromptTemplate.fromMessages([
                ["human","Element 1: {element1} Element 2: {element2}"],
              ])

              const outputParser = new JsonOutputFunctionsParser();

              const runnable = createStructuredOutputRunnable({
                outputSchema: schema,
                llm: model,
                prompt,
                outputParser,
              });
              const response: any = await runnable.invoke({
                element1,
                element2
              }).catch((e) => {
                console.error(e);
                return null;
              })

              if(response.emoji && response.emoji.length <= 0){
                return {
                    result: "Nothing",
                    emoji: "",
                    isNothing: true
                }
              }

              return response
        }
    }
)